<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temkm">/*=================================================*\&#13;
| 二分图最佳匹配（kuhn munkras算法O(m*m*n）&#13;
| 邻接距阵形式,复杂度O(m*m*n) 返回最佳匹配值,传入二分图大小m,n&#13;
| 邻接距阵mat,表示权, match1,match2返回一个最佳匹配,未匹配顶点&#13;
| match值为-1, 一定注意m&lt;=n,否则循环无法终止,最小权匹配可将权值&#13;
| 取相反数&#13;
| 初始化：for( i=0 ; i &lt; MAXN ; ++i )&#13;
|                for( j=0 ; j &lt; MAXN ; ++j ) mat[i][j] = -inf;&#13;
| 对于存在的边：mat[i][j] = val ; // 注意，不能有负值&#13;
| 此为先最大后最佳匹配，若求先最佳匹配，将init中改为mat[i][j] = 0;&#13;
\*==================================================*/&#13;
#define MAXN 310&#13;
#define inf 1000000000&#13;
#define _clr(x) memset(x,-1,sizeof(int)*MAXN*2)&#13;
int km(int m, int n, int mat[][MAXN], int* match1, int* match2) {&#13;
	int s[MAXN*2], t[MAXN*2], l1[MAXN*2], l2[MAXN*2], p, q, ret = 0, i, j, k;&#13;
	for (i = 0; i &lt; m; i++) {&#13;
		for (l1[i] = -inf, j = 0; j &lt; n; j++)&#13;
			l1[i] = mat[i][j] &gt; l1[i] ? mat[i][j] : l1[i];&#13;
		if (l1[i] == -inf)&#13;
			return -1; // 无法匹配！&#13;
	}&#13;
	for (i = 0; i &lt; n; l2[i++] = 0);&#13;
	for (_clr(match1), _clr(match2), i = 0; i &lt; m; i++) {&#13;
		for (_clr(t), s[p = q = 0] = i; p &lt;= q &amp;&amp; match1[i] &lt; 0; p++)&#13;
			for (k = s[p], j = 0; j &lt; n &amp;&amp; match1[i] &lt; 0; j++)&#13;
				if (l1[k] + l2[j] == mat[k][j] &amp;&amp; t[j] &lt; 0) {&#13;
					s[++q] = match2[j], t[j] = k;&#13;
					if (s[q] &lt; 0)&#13;
						for (p = j; p &gt;= 0; j = p)&#13;
							match2[j] = k = t[j], p = match1[k], match1[k] = j;&#13;
				}&#13;
		if (match1[i] &lt; 0) {&#13;
			for (i--, p = inf, k = 0; k &lt;= q; k++)&#13;
				for (j = 0; j &lt; n; j++)&#13;
					if (t[j] &lt; 0 &amp;&amp; l1[s[k]] + l2[j] - mat[s[k]][j] &lt; p)&#13;
						p = l1[s[k]] + l2[j] - mat[s[k]][j];&#13;
			for (j = 0; j &lt; n; l2[j] += t[j] &lt; 0 ? 0 : p, j++);&#13;
			for (k = 0; k &lt;= q; l1[s[k++]] -= p);&#13;
		}&#13;
	}&#13;
	for (i = 0; i &lt; m; i++) { // if处理无匹配的情况！！&#13;
		if (match1[i] &lt; 0)&#13;
			return -1;&#13;
		if (mat[i][match1[i]] &lt;= -inf)&#13;
			return -1;&#13;
		ret += mat[i][match1[i]];&#13;
	}&#13;
	return ret;&#13;
}&#13;
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temkm">/*=================================================*\&#13;
| 二分图最佳匹配（kuhn munkras算法O(m*m*n）&#13;
| 邻接距阵形式,复杂度O(m*m*n) 返回最佳匹配值,传入二分图大小m,n&#13;
| 邻接距阵mat,表示权, match1,match2返回一个最佳匹配,未匹配顶点&#13;
| match值为-1, 一定注意m&lt;=n,否则循环无法终止,最小权匹配可将权值&#13;
| 取相反数&#13;
| 初始化：for( i=0 ; i &lt; MAXN ; ++i )&#13;
|                for( j=0 ; j &lt; MAXN ; ++j ) mat[i][j] = -inf;&#13;
| 对于存在的边：mat[i][j] = val ; // 注意，不能有负值&#13;
| 此为先最大后最佳匹配，若求先最佳匹配，将init中改为mat[i][j] = 0;&#13;
\*==================================================*/&#13;
#define MAXN 310&#13;
#define inf 1000000000&#13;
#define _clr(x) memset(x,-1,sizeof(int)*MAXN*2)&#13;
int km(int m, int n, int mat[][MAXN], int* match1, int* match2) {&#13;
	int s[MAXN*2], t[MAXN*2], l1[MAXN*2], l2[MAXN*2], p, q, ret = 0, i, j, k;&#13;
	for (i = 0; i &lt; m; i++) {&#13;
		for (l1[i] = -inf, j = 0; j &lt; n; j++)&#13;
			l1[i] = mat[i][j] &gt; l1[i] ? mat[i][j] : l1[i];&#13;
		if (l1[i] == -inf)&#13;
			return -1; // 无法匹配！&#13;
	}&#13;
	for (i = 0; i &lt; n; l2[i++] = 0);&#13;
	for (_clr(match1), _clr(match2), i = 0; i &lt; m; i++) {&#13;
		for (_clr(t), s[p = q = 0] = i; p &lt;= q &amp;&amp; match1[i] &lt; 0; p++)&#13;
			for (k = s[p], j = 0; j &lt; n &amp;&amp; match1[i] &lt; 0; j++)&#13;
				if (l1[k] + l2[j] == mat[k][j] &amp;&amp; t[j] &lt; 0) {&#13;
					s[++q] = match2[j], t[j] = k;&#13;
					if (s[q] &lt; 0)&#13;
						for (p = j; p &gt;= 0; j = p)&#13;
							match2[j] = k = t[j], p = match1[k], match1[k] = j;&#13;
				}&#13;
		if (match1[i] &lt; 0) {&#13;
			for (i--, p = inf, k = 0; k &lt;= q; k++)&#13;
				for (j = 0; j &lt; n; j++)&#13;
					if (t[j] &lt; 0 &amp;&amp; l1[s[k]] + l2[j] - mat[s[k]][j] &lt; p)&#13;
						p = l1[s[k]] + l2[j] - mat[s[k]][j];&#13;
			for (j = 0; j &lt; n; l2[j] += t[j] &lt; 0 ? 0 : p, j++);&#13;
			for (k = 0; k &lt;= q; l1[s[k++]] -= p);&#13;
		}&#13;
	}&#13;
	for (i = 0; i &lt; m; i++) { // if处理无匹配的情况！！&#13;
		if (match1[i] &lt; 0)&#13;
			return -1;&#13;
		if (mat[i][match1[i]] &lt;= -inf)&#13;
			return -1;&#13;
		ret += mat[i][match1[i]];&#13;
	}&#13;
	return ret;&#13;
}&#13;
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temlca(da)">/*&#13;
 * init: memset(fa, -1, sizeof(fa));&#13;
 *      dfs(root); // get deep, fa[i][0]&#13;
 *      initfa();&#13;
 */&#13;
int fa[maxn][22], deep[maxn];&#13;
&#13;
inline void initfa() {&#13;
	for(int i = 1; i &lt;= 20; i++) {&#13;
		for(int j = 0; j &lt; n; j++) {&#13;
			if(fa[j][i - 1] == -1) fa[j][i] = -1;&#13;
			else fa[j][i] = fa[fa[j][i - 1]][i - 1];&#13;
		}&#13;
	}&#13;
}&#13;
inline int getfa(int no, int l) {&#13;
	for(int i = 0; l; l &gt;&gt;= 1, i++)&#13;
		if(l &amp; 1) no = fa[no][i];&#13;
	return no;&#13;
}&#13;
inline int getlca(int a, int b) {&#13;
	if(deep[a] &gt; deep[b]) swap(a, b);&#13;
	b = getfa(b, deep[b] - deep[a]);&#13;
	if(b == a) return a;&#13;
	for(int i = 20; i &gt;= 0; i--)&#13;
		if(fa[a][i] != fa[b][i]){&#13;
			a = fa[a][i];&#13;
			b = fa[b][i];&#13;
		}&#13;
	return fa[a][0];&#13;
}&#13;
inline int getl(int a, int b) {&#13;
	int faa = getlca(a, b);&#13;
	return deep[a] + deep[b] - deep[faa] * 2;&#13;
}&#13;
&#13;
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temlca(da)">/*&#13;
 * init: memset(fa, -1, sizeof(fa));&#13;
 *      dfs(root); // get deep, fa[i][0]&#13;
 *      initfa();&#13;
 */&#13;
int fa[maxn][22], deep[maxn];&#13;
&#13;
inline void initfa() {&#13;
	for(int i = 1; i &lt;= 20; i++) {&#13;
		for(int j = 0; j &lt; n; j++) {&#13;
			if(fa[j][i - 1] == -1) fa[j][i] = -1;&#13;
			else fa[j][i] = fa[fa[j][i - 1]][i - 1];&#13;
		}&#13;
	}&#13;
}&#13;
inline int getfa(int no, int l) {&#13;
	for(int i = 0; l; l &gt;&gt;= 1, i++)&#13;
		if(l &amp; 1) no = fa[no][i];&#13;
	return no;&#13;
}&#13;
inline int getlca(int a, int b) {&#13;
	if(deep[a] &gt; deep[b]) swap(a, b);&#13;
	b = getfa(b, deep[b] - deep[a]);&#13;
	if(b == a) return a;&#13;
	for(int i = 20; i &gt;= 0; i--)&#13;
		if(fa[a][i] != fa[b][i]){&#13;
			a = fa[a][i];&#13;
			b = fa[b][i];&#13;
		}&#13;
	return fa[a][0];&#13;
}&#13;
inline int getl(int a, int b) {&#13;
	int faa = getlca(a, b);&#13;
	return deep[a] + deep[b] - deep[faa] * 2;&#13;
}&#13;
&#13;
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temmatrix">template &lt;typename t&gt; struct matrix{&#13;
	const static int maxn = 200;&#13;
	int row, col;&#13;
	t mat[maxn][maxn];&#13;
&#13;
	matrix(int r = 0, int c = 0){&#13;
		row = r; col = c;&#13;
		for(int i = 0; i &lt; row; i++) for(int j = 0; j &lt; col; j++) mat[i][j] = 0;&#13;
	}&#13;
	const t * operator[] (int i) const {&#13;
		return mat[i];&#13;
	}&#13;
	t * operator[] (int i) {&#13;
		return mat[i];	&#13;
	}&#13;
	bool danweiju(){&#13;
		if(row != col) return 0;&#13;
		for(int i = 0; i &lt; row; i++) for(int j = 0; j &lt; col; j++) mat[i][j] = bool (i == j);&#13;
		return 1;&#13;
	}&#13;
	matrix operator * (const matrix&amp; b) const{&#13;
		int i, j, k;&#13;
		matrix &lt;t&gt; c(row, b.col);&#13;
		memset(c.mat, 0, sizeof(c.mat));&#13;
		for (i = 0; i &lt; c.row; i++) for (k = 0; k &lt; col; k++)&#13;
			if(mat[i][k])&#13;
				for (j = 0; j &lt; c.col; j++){&#13;
					c.mat[i][j] += mat[i][k] * b.mat[k][j];&#13;
				}&#13;
		return c;&#13;
	}&#13;
	matrix operator + (const matrix&amp; b) const{&#13;
		matrix &lt;t&gt; c(max1(row, b.row), max1(col, b.col));&#13;
		for(int i = 0; i &lt; c.row; i++) for(int j = 0; j &lt; c.col; j++){&#13;
			t a = 0; if(i &lt; row &amp;&amp; j &lt; col) a = mat[i][j];&#13;
			t b1 = 0; if(i &lt; b.row &amp;&amp; j &lt; b.col) b1 = b.mat[i][j];&#13;
			c.mat[i][j] = a + b1;&#13;
		}&#13;
		return c;&#13;
	}&#13;
	matrix operator - (const matrix&amp; b) const{&#13;
		matrix &lt;t&gt; c(max1(row, b.row), max1(col, b.col));&#13;
		for(int i = 0; i &lt; c.row; i++) for(int j = 0; j &lt; c.col; j++){&#13;
			t a = 0; if(i &lt; row &amp;&amp; j &lt; col) a = mat[i][j];&#13;
			t b1 = 0; if(i &lt; b.row &amp;&amp; j &lt; b.col) b1 = b.mat[i][j];&#13;
			c.mat[i][j] = a - b1;&#13;
		}&#13;
		return c;&#13;
	}&#13;
	inline void operator = (const matrix &amp; b){&#13;
		memcpy(mat, b.mat, sizeof(mat));&#13;
		col = b.col;  row = b.row;&#13;
	}&#13;
	matrix pow(long long n){&#13;
		matrix &lt;t&gt; ans(row, col), temp = *this;&#13;
&#13;
		ans.danweiju();&#13;
		while(n){&#13;
			if(n &amp; 1) ans = ans * temp;&#13;
			temp = temp * temp;&#13;
			n &gt;&gt;= 1;&#13;
		}&#13;
		return ans;&#13;
	}&#13;
	matrix addpow(long long n) {// calculate 1 + m + m ^ 2 + ... + m ^ n&#13;
		n++;&#13;
		matrix &lt;t&gt; ans(row, col), temp = *this, temp1(row, col), ans1(row, col);&#13;
&#13;
		ans.danweiju(); temp1.danweiju();&#13;
		while(n){&#13;
			if(n &amp; 1){&#13;
				ans1 = ans1 + ans * temp1;&#13;
				temp1 = temp * temp1;&#13;
			}&#13;
			ans = ans + ans * temp;&#13;
			temp = temp * temp;&#13;
			n &gt;&gt;= 1;&#13;
		}&#13;
		return ans1;&#13;
	}&#13;
	int inv(){&#13;
		int i, j, k, is[maxn], js[maxn];&#13;
		double t1;&#13;
&#13;
		if (row != col) return 0;&#13;
		for(k = 0; k &lt; row; k++){&#13;
			for(t1 = 0,i = k; i &lt; row; i++) for(j = k; j &lt; row; j++)&#13;
				if(fabs(mat[i][j]) &gt; t1)&#13;
					t1=fabs(mat[is[k] = i][js[k] = j]);&#13;
			if (fabs(t1 - 0) &lt; 1e-9) return 0;&#13;
			if (is[k] != k) for(j = 0; j &lt; row; j++)&#13;
				t1 = mat[k][j], mat[k][j] = mat[is[k]][j], mat[is[k]][j] = t1;&#13;
			if (js[k] != k) for (i = 0; i &lt; row; i++)&#13;
				t1 = mat[i][k], mat[i][k] = mat[i][js[k]], mat[i][js[k]] = t1;&#13;
			mat[k][k] = 1 / mat[k][k];&#13;
			for(j = 0; j &lt; row; j++) if (j != k)&#13;
				mat[k][j] *= mat[k][k];&#13;
			for (i = 0; i &lt; row; i++)	if (i != k)&#13;
				for (j = 0; j &lt; row; j++) if (j != k)&#13;
					mat[i][j] -= mat[i][k] * mat[k][j];&#13;
			for (i = 0;i &lt; row; i++) if (i != k)&#13;
				mat[i][k] *= -mat[k][k];&#13;
		}&#13;
		for (k = row-1; k &gt;= 0; k--){&#13;
			for (j = 0; j &lt; row; j++) if (js[k] != k)&#13;
					t1 = mat[k][j], mat[k][j] = mat[js[k]][j], mat[js[k]][j]=t1;&#13;
			for (i = 0; i &lt; row; i++) if (is[k] != k)&#13;
				t1 = mat[i][k], mat[i][k] = mat[i][is[k]], mat[i][is[k]] = t1;&#13;
		}&#13;
		return 1;&#13;
	}&#13;
	double det(){&#13;
		int i, j, k, sign = 0;&#13;
		double b[maxn][maxn], ret = 1, t1;&#13;
&#13;
		if (row != col) return 0;&#13;
		for (i = 0; i &lt; row; i++) for (j = 0; j &lt; col; j++)&#13;
			b[i][j] = mat[i][j];&#13;
		for (i = 0; i &lt; row; i++){&#13;
			if (fabs(b[i][i] - 0) &lt; 1e-9){&#13;
				for (j = i + 1; j &lt; row; j++)&#13;
					if (fabs(b[j][i] - 0) &gt; 1e-9) break;&#13;
					if (j == row) return 0;&#13;
					for (k = i; k &lt; row; k++)&#13;
						t1 = b[i][k], b[i][k] = b[j][k], b[j][k] = t1;&#13;
					sign++;&#13;
			}&#13;
			ret *= b[i][i];&#13;
			for (k = i + 1; k &lt; row; k++) b[i][k] /= b[i][i];&#13;
			for (j = i + 1; j &lt; row; j++) for (k = i + 1; k &lt; row; k++)&#13;
				b[j][k] -= b[j][i] * b[i][k];&#13;
		}&#13;
		if (sign &amp; 1) ret = -ret;&#13;
		return ret;&#13;
	}&#13;
};</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temmatrix">template &lt;typename t&gt; struct matrix{&#13;
	const static int maxn = 200;&#13;
	int row, col;&#13;
	t mat[maxn][maxn];&#13;
&#13;
	matrix(int r = 0, int c = 0){&#13;
		row = r; col = c;&#13;
		for(int i = 0; i &lt; row; i++) for(int j = 0; j &lt; col; j++) mat[i][j] = 0;&#13;
	}&#13;
	const t * operator[] (int i) const {&#13;
		return mat[i];&#13;
	}&#13;
	t * operator[] (int i) {&#13;
		return mat[i];	&#13;
	}&#13;
	bool danweiju(){&#13;
		if(row != col) return 0;&#13;
		for(int i = 0; i &lt; row; i++) for(int j = 0; j &lt; col; j++) mat[i][j] = bool (i == j);&#13;
		return 1;&#13;
	}&#13;
	matrix operator * (const matrix&amp; b) const{&#13;
		int i, j, k;&#13;
		matrix &lt;t&gt; c(row, b.col);&#13;
		memset(c.mat, 0, sizeof(c.mat));&#13;
		for (i = 0; i &lt; c.row; i++) for (k = 0; k &lt; col; k++)&#13;
			if(mat[i][k])&#13;
				for (j = 0; j &lt; c.col; j++){&#13;
					c.mat[i][j] += mat[i][k] * b.mat[k][j];&#13;
				}&#13;
		return c;&#13;
	}&#13;
	matrix operator + (const matrix&amp; b) const{&#13;
		matrix &lt;t&gt; c(max1(row, b.row), max1(col, b.col));&#13;
		for(int i = 0; i &lt; c.row; i++) for(int j = 0; j &lt; c.col; j++){&#13;
			t a = 0; if(i &lt; row &amp;&amp; j &lt; col) a = mat[i][j];&#13;
			t b1 = 0; if(i &lt; b.row &amp;&amp; j &lt; b.col) b1 = b.mat[i][j];&#13;
			c.mat[i][j] = a + b1;&#13;
		}&#13;
		return c;&#13;
	}&#13;
	matrix operator - (const matrix&amp; b) const{&#13;
		matrix &lt;t&gt; c(max1(row, b.row), max1(col, b.col));&#13;
		for(int i = 0; i &lt; c.row; i++) for(int j = 0; j &lt; c.col; j++){&#13;
			t a = 0; if(i &lt; row &amp;&amp; j &lt; col) a = mat[i][j];&#13;
			t b1 = 0; if(i &lt; b.row &amp;&amp; j &lt; b.col) b1 = b.mat[i][j];&#13;
			c.mat[i][j] = a - b1;&#13;
		}&#13;
		return c;&#13;
	}&#13;
	inline void operator = (const matrix &amp; b){&#13;
		memcpy(mat, b.mat, sizeof(mat));&#13;
		col = b.col;  row = b.row;&#13;
	}&#13;
	matrix pow(long long n){&#13;
		matrix &lt;t&gt; ans(row, col), temp = *this;&#13;
&#13;
		ans.danweiju();&#13;
		while(n){&#13;
			if(n &amp; 1) ans = ans * temp;&#13;
			temp = temp * temp;&#13;
			n &gt;&gt;= 1;&#13;
		}&#13;
		return ans;&#13;
	}&#13;
	matrix addpow(long long n) {// calculate 1 + m + m ^ 2 + ... + m ^ n&#13;
		n++;&#13;
		matrix &lt;t&gt; ans(row, col), temp = *this, temp1(row, col), ans1(row, col);&#13;
&#13;
		ans.danweiju(); temp1.danweiju();&#13;
		while(n){&#13;
			if(n &amp; 1){&#13;
				ans1 = ans1 + ans * temp1;&#13;
				temp1 = temp * temp1;&#13;
			}&#13;
			ans = ans + ans * temp;&#13;
			temp = temp * temp;&#13;
			n &gt;&gt;= 1;&#13;
		}&#13;
		return ans1;&#13;
	}&#13;
	int inv(){&#13;
		int i, j, k, is[maxn], js[maxn];&#13;
		double t1;&#13;
&#13;
		if (row != col) return 0;&#13;
		for(k = 0; k &lt; row; k++){&#13;
			for(t1 = 0,i = k; i &lt; row; i++) for(j = k; j &lt; row; j++)&#13;
				if(fabs(mat[i][j]) &gt; t1)&#13;
					t1=fabs(mat[is[k] = i][js[k] = j]);&#13;
			if (fabs(t1 - 0) &lt; 1e-9) return 0;&#13;
			if (is[k] != k) for(j = 0; j &lt; row; j++)&#13;
				t1 = mat[k][j], mat[k][j] = mat[is[k]][j], mat[is[k]][j] = t1;&#13;
			if (js[k] != k) for (i = 0; i &lt; row; i++)&#13;
				t1 = mat[i][k], mat[i][k] = mat[i][js[k]], mat[i][js[k]] = t1;&#13;
			mat[k][k] = 1 / mat[k][k];&#13;
			for(j = 0; j &lt; row; j++) if (j != k)&#13;
				mat[k][j] *= mat[k][k];&#13;
			for (i = 0; i &lt; row; i++)	if (i != k)&#13;
				for (j = 0; j &lt; row; j++) if (j != k)&#13;
					mat[i][j] -= mat[i][k] * mat[k][j];&#13;
			for (i = 0;i &lt; row; i++) if (i != k)&#13;
				mat[i][k] *= -mat[k][k];&#13;
		}&#13;
		for (k = row-1; k &gt;= 0; k--){&#13;
			for (j = 0; j &lt; row; j++) if (js[k] != k)&#13;
					t1 = mat[k][j], mat[k][j] = mat[js[k]][j], mat[js[k]][j]=t1;&#13;
			for (i = 0; i &lt; row; i++) if (is[k] != k)&#13;
				t1 = mat[i][k], mat[i][k] = mat[i][is[k]], mat[i][is[k]] = t1;&#13;
		}&#13;
		return 1;&#13;
	}&#13;
	double det(){&#13;
		int i, j, k, sign = 0;&#13;
		double b[maxn][maxn], ret = 1, t1;&#13;
&#13;
		if (row != col) return 0;&#13;
		for (i = 0; i &lt; row; i++) for (j = 0; j &lt; col; j++)&#13;
			b[i][j] = mat[i][j];&#13;
		for (i = 0; i &lt; row; i++){&#13;
			if (fabs(b[i][i] - 0) &lt; 1e-9){&#13;
				for (j = i + 1; j &lt; row; j++)&#13;
					if (fabs(b[j][i] - 0) &gt; 1e-9) break;&#13;
					if (j == row) return 0;&#13;
					for (k = i; k &lt; row; k++)&#13;
						t1 = b[i][k], b[i][k] = b[j][k], b[j][k] = t1;&#13;
					sign++;&#13;
			}&#13;
			ret *= b[i][i];&#13;
			for (k = i + 1; k &lt; row; k++) b[i][k] /= b[i][i];&#13;
			for (j = i + 1; j &lt; row; j++) for (k = i + 1; k &lt; row; k++)&#13;
				b[j][k] -= b[j][i] * b[i][k];&#13;
		}&#13;
		if (sign &amp; 1) ret = -ret;&#13;
		return ret;&#13;
	}&#13;
};</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temmincostflow">/*===================================================================*\&#13;
| 最小费用流 O(V * E * f)&#13;
| INIT: network g; g.build(v); for(int i = 0; i &lt; e; e++) addedge(a, b, capcity, cost);&#13;
| CALL: g.mincost(s, t); flow=g.flow; cost=g.cost;&#13;
| 注意: SPFA增广, 实际复杂度远远小于O(V * E);&#13;
\*===================================================================*/&#13;
#define typef int // type of flow&#13;
#define typec int // type of dis&#13;
const typef inff = 0x3f3f3f3f; // max of flow&#13;
const typec infc = 0x3f3f3f3f; // max of dis&#13;
const int E = 200100;&#13;
const int N = 20000;&#13;
struct network {&#13;
	int nv, ne, pnt[E], nxt[E];&#13;
	int vis[N], que[N], head[N], pv[N], pe[N];typef flow, cap[E];typec cost,&#13;
			dis[E], d[N];&#13;
	void addedge(int u, int v, typef c, typec w) {&#13;
		pnt[ne] = v;&#13;
		cap[ne] = c;&#13;
		dis[ne] = +w;&#13;
		nxt[ne] = head[u];&#13;
		head[u] = (ne++);&#13;
		pnt[ne] = u;&#13;
		cap[ne] = 0;&#13;
		dis[ne] = -w;&#13;
		nxt[ne] = head[v];&#13;
		head[v] = (ne++);&#13;
	}&#13;
	int mincost(int src, int sink) {&#13;
		int i, k, f, r;&#13;
		typef mxf;&#13;
		for (flow = 0, cost = 0;;) {&#13;
			memset(pv, -1, sizeof(pv));&#13;
			memset(vis, 0, sizeof(vis));&#13;
			for (i = 0; i &lt; nv; ++i)&#13;
				d[i] = infc;&#13;
			d[src] = 0;&#13;
			pv[src] = src;&#13;
			vis[src] = 1;&#13;
			for (f = 0, r = 1, que[0] = src; r != f;) {&#13;
				i = que[f++];&#13;
				vis[i] = 0;&#13;
				if (N == f)&#13;
					f = 0;&#13;
				for (k = head[i]; k != -1; k = nxt[k])&#13;
					if (cap[k] &amp;&amp; dis[k] + d[i] &lt; d[pnt[k]]) {&#13;
						d[pnt[k]] = dis[k] + d[i];&#13;
						if (0 == vis[pnt[k]]) {&#13;
							vis[pnt[k]] = 1;&#13;
							que[r++] = pnt[k];&#13;
							if (N == r)&#13;
								r = 0;&#13;
						}&#13;
						pv[pnt[k]] = i;&#13;
						pe[pnt[k]] = k;&#13;
					}&#13;
			}&#13;
			if (-1 == pv[sink])&#13;
				break;&#13;
			for (k = sink, mxf = inff; k != src; k = pv[k])&#13;
				if (cap[pe[k]] &lt; mxf)&#13;
					mxf = cap[pe[k]];&#13;
			flow += mxf;&#13;
			cost += d[sink] * mxf;&#13;
			for (k = sink; k != src; k = pv[k]) {&#13;
				cap[pe[k]] -= mxf;&#13;
				cap[pe[k] ^ 1] += mxf;&#13;
			}&#13;
		}&#13;
		return cost;&#13;
	}&#13;
	void init(int v) {&#13;
		nv = v;&#13;
		ne = 0;&#13;
		memset(head, -1, sizeof(head));&#13;
	}&#13;
} g;</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temmincostflow">/*===================================================================*\&#13;
| 最小费用流 O(V * E * f)&#13;
| INIT: network g; g.build(v); for(int i = 0; i &lt; e; e++) addedge(a, b, capcity, cost);&#13;
| CALL: g.mincost(s, t); flow=g.flow; cost=g.cost;&#13;
| 注意: SPFA增广, 实际复杂度远远小于O(V * E);&#13;
\*===================================================================*/&#13;
#define typef int // type of flow&#13;
#define typec int // type of dis&#13;
const typef inff = 0x3f3f3f3f; // max of flow&#13;
const typec infc = 0x3f3f3f3f; // max of dis&#13;
const int E = 200100;&#13;
const int N = 20000;&#13;
struct network {&#13;
	int nv, ne, pnt[E], nxt[E];&#13;
	int vis[N], que[N], head[N], pv[N], pe[N];typef flow, cap[E];typec cost,&#13;
			dis[E], d[N];&#13;
	void addedge(int u, int v, typef c, typec w) {&#13;
		pnt[ne] = v;&#13;
		cap[ne] = c;&#13;
		dis[ne] = +w;&#13;
		nxt[ne] = head[u];&#13;
		head[u] = (ne++);&#13;
		pnt[ne] = u;&#13;
		cap[ne] = 0;&#13;
		dis[ne] = -w;&#13;
		nxt[ne] = head[v];&#13;
		head[v] = (ne++);&#13;
	}&#13;
	int mincost(int src, int sink) {&#13;
		int i, k, f, r;&#13;
		typef mxf;&#13;
		for (flow = 0, cost = 0;;) {&#13;
			memset(pv, -1, sizeof(pv));&#13;
			memset(vis, 0, sizeof(vis));&#13;
			for (i = 0; i &lt; nv; ++i)&#13;
				d[i] = infc;&#13;
			d[src] = 0;&#13;
			pv[src] = src;&#13;
			vis[src] = 1;&#13;
			for (f = 0, r = 1, que[0] = src; r != f;) {&#13;
				i = que[f++];&#13;
				vis[i] = 0;&#13;
				if (N == f)&#13;
					f = 0;&#13;
				for (k = head[i]; k != -1; k = nxt[k])&#13;
					if (cap[k] &amp;&amp; dis[k] + d[i] &lt; d[pnt[k]]) {&#13;
						d[pnt[k]] = dis[k] + d[i];&#13;
						if (0 == vis[pnt[k]]) {&#13;
							vis[pnt[k]] = 1;&#13;
							que[r++] = pnt[k];&#13;
							if (N == r)&#13;
								r = 0;&#13;
						}&#13;
						pv[pnt[k]] = i;&#13;
						pe[pnt[k]] = k;&#13;
					}&#13;
			}&#13;
			if (-1 == pv[sink])&#13;
				break;&#13;
			for (k = sink, mxf = inff; k != src; k = pv[k])&#13;
				if (cap[pe[k]] &lt; mxf)&#13;
					mxf = cap[pe[k]];&#13;
			flow += mxf;&#13;
			cost += d[sink] * mxf;&#13;
			for (k = sink; k != src; k = pv[k]) {&#13;
				cap[pe[k]] -= mxf;&#13;
				cap[pe[k] ^ 1] += mxf;&#13;
			}&#13;
		}&#13;
		return cost;&#13;
	}&#13;
	void init(int v) {&#13;
		nv = v;&#13;
		ne = 0;&#13;
		memset(head, -1, sizeof(head));&#13;
	}&#13;
} g;</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="the template of SAP" enabled="true" name="temsap">/*&#13;
 *  call ::&#13;
 *  pre(n, source, terminal);&#13;
 *  for(int i = 0; i &lt; m; i++) {&#13;
 *  	addedge(from, to, capcity);&#13;
 *  }&#13;
 *  SAP();&#13;
 *&#13;
 *  返回maxflow;&#13;
 */&#13;
#define MAXM ${mm}&#13;
#define MAXN ${mn}&#13;
#define Clr(x) memset(x,0,sizeof(x))&#13;
#define INF 0x5fffffff&#13;
&#13;
struct sap {&#13;
	struct edge {&#13;
		int to, cap, next;&#13;
	} e[MAXM * 2];&#13;
&#13;
	int p, head[MAXN], h[MAXN], vh[MAXN];&#13;
	int n, m, s, t, maxFlow;&#13;
&#13;
	inline int min(int a, int b) {&#13;
		return a &lt; b ? a : b;&#13;
	}&#13;
	inline void addedge(int a, int b, int c) {&#13;
		e[p].to = b, e[p].cap = c, e[p].next = head[a], head[a] = p++;&#13;
		e[p].to = a, e[p].cap = 0, e[p].next = head[b], head[b] = p++;&#13;
	}&#13;
	int dfs(int u, int pre) {&#13;
		if (u == t)&#13;
			return pre;&#13;
		int now, aug, mh = n + 10, to, tmp = pre;&#13;
		for (now = head[u]; now; now = e[now].next) {&#13;
			to = e[now].to;&#13;
			if (e[now].cap) {&#13;
				if (pre &amp;&amp; h[u] == h[to] + 1) {&#13;
					aug = dfs(to, min(pre, e[now].cap));&#13;
					pre -= aug;&#13;
					e[now].cap -= aug;&#13;
					e[now ^ 1].cap += aug;&#13;
					if (h[s] &gt;= n)&#13;
						return tmp - pre;&#13;
				}&#13;
				mh = min(mh, h[to]);&#13;
			}&#13;
		}&#13;
		if (tmp - pre &gt; 0)&#13;
			return tmp - pre;&#13;
		--vh[h[u]];&#13;
		if (!vh[h[u]]) {&#13;
			h[s] = n;&#13;
			return 0;&#13;
		}&#13;
		++vh[h[u] = mh + 1];&#13;
		return 0;&#13;
	}&#13;
&#13;
	void init() {&#13;
		maxFlow = 0;&#13;
		Clr(h);&#13;
		Clr(vh);&#13;
		vh[0] = n;&#13;
	}&#13;
	void SAP() {&#13;
		init();&#13;
		while (h[s] &lt; n)&#13;
			maxFlow += dfs(s, INF);&#13;
	}&#13;
	void pre(int nn, int ss = -1, int tt = -1) {&#13;
		p = 2;&#13;
		Clr(head);&#13;
		n = nn;&#13;
		if(ss == -1) s = 0;&#13;
		else s = ss;&#13;
		if (tt == -1) t = n - 1;&#13;
		else t = tt;&#13;
	}&#13;
} g;&#13;
${cursor}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="the template of SAP" enabled="true" name="temsap">/*&#13;
 *  call ::&#13;
 *  pre(n, source, terminal);&#13;
 *  for(int i = 0; i &lt; m; i++) {&#13;
 *  	addedge(from, to, capcity);&#13;
 *  }&#13;
 *  SAP();&#13;
 *&#13;
 *  返回maxflow;&#13;
 */&#13;
#define MAXM ${mm}&#13;
#define MAXN ${mn}&#13;
#define Clr(x) memset(x,0,sizeof(x))&#13;
#define INF 0x5fffffff&#13;
&#13;
struct sap {&#13;
	struct edge {&#13;
		int to, cap, next;&#13;
	} e[MAXM * 2];&#13;
&#13;
	int p, head[MAXN], h[MAXN], vh[MAXN];&#13;
	int n, m, s, t, maxFlow;&#13;
&#13;
	inline int min(int a, int b) {&#13;
		return a &lt; b ? a : b;&#13;
	}&#13;
	inline void addedge(int a, int b, int c) {&#13;
		e[p].to = b, e[p].cap = c, e[p].next = head[a], head[a] = p++;&#13;
		e[p].to = a, e[p].cap = 0, e[p].next = head[b], head[b] = p++;&#13;
	}&#13;
	int dfs(int u, int pre) {&#13;
		if (u == t)&#13;
			return pre;&#13;
		int now, aug, mh = n + 10, to, tmp = pre;&#13;
		for (now = head[u]; now; now = e[now].next) {&#13;
			to = e[now].to;&#13;
			if (e[now].cap) {&#13;
				if (pre &amp;&amp; h[u] == h[to] + 1) {&#13;
					aug = dfs(to, min(pre, e[now].cap));&#13;
					pre -= aug;&#13;
					e[now].cap -= aug;&#13;
					e[now ^ 1].cap += aug;&#13;
					if (h[s] &gt;= n)&#13;
						return tmp - pre;&#13;
				}&#13;
				mh = min(mh, h[to]);&#13;
			}&#13;
		}&#13;
		if (tmp - pre &gt; 0)&#13;
			return tmp - pre;&#13;
		--vh[h[u]];&#13;
		if (!vh[h[u]]) {&#13;
			h[s] = n;&#13;
			return 0;&#13;
		}&#13;
		++vh[h[u] = mh + 1];&#13;
		return 0;&#13;
	}&#13;
&#13;
	void init() {&#13;
		maxFlow = 0;&#13;
		Clr(h);&#13;
		Clr(vh);&#13;
		vh[0] = n;&#13;
	}&#13;
	void SAP() {&#13;
		init();&#13;
		while (h[s] &lt; n)&#13;
			maxFlow += dfs(s, INF);&#13;
	}&#13;
	void pre(int nn, int ss = -1, int tt = -1) {&#13;
		p = 2;&#13;
		Clr(head);&#13;
		n = nn;&#13;
		if(ss == -1) s = 0;&#13;
		else s = ss;&#13;
		if (tt == -1) t = n - 1;&#13;
		else t = tt;&#13;
	}&#13;
} g;&#13;
${cursor}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="template of segment tree" enabled="true" name="temsegmenttree">#ifndef N&#13;
#define N 200100&#13;
#endif&#13;
template &lt;class t&gt; struct segment_node{&#13;
	int be, en;&#13;
	t maxv, add, sum;&#13;
};&#13;
template &lt;class t&gt; struct segment_tree{&#13;
	int l;&#13;
	segment_node &lt;t&gt; tree[N * 4];&#13;
&#13;
	inline int gleft(int no) {return no &lt;&lt; 1;}&#13;
	inline int gright(int no) {return (no &lt;&lt; 1) + 1;}&#13;
	inline int gfa(int no) {return no &gt;&gt; 1;}&#13;
	inline segment_tree(){ l = 0; }&#13;
&#13;
	void build(int no, int l, int r, t orig = 0, t *a = NULL){&#13;
		if(l &gt; r) r = l;&#13;
		if(l == r){&#13;
			tree[no].be = tree[no].en = l;&#13;
			tree[no].add = 0;&#13;
			if(a == NULL) tree[no].maxv = orig;&#13;
			else tree[no].maxv = a[l];&#13;
			tree[no].add = 0;&#13;
			tree[no].sum = tree[no].maxv;&#13;
			return;&#13;
		}&#13;
		tree[no].be = l; tree[no].en = r;&#13;
		int mid = (l + r) / 2;&#13;
		build(gleft(no), l, mid, orig, a);&#13;
		build(gright(no), mid + 1, r, orig, a);&#13;
		tree[no].sum = tree[gleft(no)].sum + tree[gright(no)].sum;&#13;
		tree[no].add = 0;&#13;
		tree[no].maxv = max1(tree[gleft(no)].maxv, tree[gright(no)].maxv);&#13;
	}&#13;
	inline void relax(int no) {&#13;
		int le = gleft(no), ri = gright(no);&#13;
		tree[le].add += tree[no].add;&#13;
		tree[le].sum += tree[no].add * (tree[le].en - tree[le].be + 1);&#13;
		tree[le].maxv += tree[no].add;&#13;
		tree[ri].add += tree[no].add;&#13;
		tree[ri].sum += tree[no].add * (tree[ri].en - tree[ri].be + 1);&#13;
		tree[ri].maxv += tree[no].add;&#13;
		tree[no].add = 0;&#13;
	}&#13;
	void down(int l, int r, int no, t ranadd){&#13;
		if(l &lt;= tree[no].be &amp;&amp; r &gt;= tree[no].en){&#13;
			tree[no].add += ranadd;&#13;
			tree[no].sum += ranadd * (tree[no].en - tree[no].be + 1);&#13;
			tree[no].maxv += ranadd;&#13;
			return;&#13;
		}&#13;
		if(tree[no].add &amp;&amp; tree[no].be != tree[no].en) relax(no);&#13;
		int mid = (tree[no].be + tree[no].en) &gt;&gt; 1;&#13;
		if(r &gt;= tree[no].be &amp;&amp; l &lt;= mid) down(l, r, gleft(no), ranadd);&#13;
		if(r &gt;= mid + 1 &amp;&amp; l &lt;= tree[no].en) down(l, r, gright(no), ranadd);&#13;
		tree[no].sum = tree[gleft(no)].sum + tree[gright(no)].sum;&#13;
		tree[no].maxv = max1(tree[gleft(no)].maxv, tree[gright(no)].maxv);&#13;
	}&#13;
	t getsum(int l, int r, int no){&#13;
		if(l &gt; r) return 0;&#13;
		if(l &lt;= tree[no].be &amp;&amp; r &gt;= tree[no].en)&#13;
			return tree[no].sum;&#13;
		if(tree[no].add &amp;&amp; tree[no].be != tree[no].en) relax(no);&#13;
		t ans = 0;&#13;
		int mid = (tree[no].be + tree[no].en) &gt;&gt; 1;&#13;
		if(r &gt;= tree[no].be &amp;&amp; l &lt;= mid) ans += getsum(l, r, gleft(no));&#13;
		if(r &gt;= mid + 1 &amp;&amp; l &lt;= tree[no].en) ans += getsum(l, r, gright(no));&#13;
		return ans;&#13;
	}&#13;
	int getrank(int rank, int no){&#13;
		if(rank &gt; tree[no].sum) return -1;&#13;
		if(tree[no].be == tree[no].en) return tree[no].be;&#13;
		if(tree[no].add &amp;&amp; tree[no].be != tree[no].en) relax(no);&#13;
		int mid = (tree[no].be + tree[no].en) &gt;&gt; 1;&#13;
		if(rank &lt;= tree[gleft(no)].sum) return getrank(rank, gleft(no));&#13;
		return getrank(rank - tree[gleft(no)].sum, gright(no));&#13;
	}&#13;
	inline int section_getrank(int l, int r, int rank){&#13;
		return getrank(rank + getsum(0, l - 1, 1), 1);&#13;
	}&#13;
};&#13;
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="template of segment tree" enabled="true" name="temsegmenttree">#ifndef N&#13;
#define N 200100&#13;
#endif&#13;
template &lt;class t&gt; struct segment_node{&#13;
	int be, en;&#13;
	t maxv, add, sum;&#13;
};&#13;
template &lt;class t&gt; struct segment_tree{&#13;
	int l;&#13;
	segment_node &lt;t&gt; tree[N * 4];&#13;
&#13;
	inline int gleft(int no) {return no &lt;&lt; 1;}&#13;
	inline int gright(int no) {return (no &lt;&lt; 1) + 1;}&#13;
	inline int gfa(int no) {return no &gt;&gt; 1;}&#13;
	inline segment_tree(){ l = 0; }&#13;
&#13;
	void build(int no, int l, int r, t orig = 0, t *a = NULL){&#13;
		if(l &gt; r) r = l;&#13;
		if(l == r){&#13;
			tree[no].be = tree[no].en = l;&#13;
			tree[no].add = 0;&#13;
			if(a == NULL) tree[no].maxv = orig;&#13;
			else tree[no].maxv = a[l];&#13;
			tree[no].add = 0;&#13;
			tree[no].sum = tree[no].maxv;&#13;
			return;&#13;
		}&#13;
		tree[no].be = l; tree[no].en = r;&#13;
		int mid = (l + r) / 2;&#13;
		build(gleft(no), l, mid, orig, a);&#13;
		build(gright(no), mid + 1, r, orig, a);&#13;
		tree[no].sum = tree[gleft(no)].sum + tree[gright(no)].sum;&#13;
		tree[no].add = 0;&#13;
		tree[no].maxv = max1(tree[gleft(no)].maxv, tree[gright(no)].maxv);&#13;
	}&#13;
	inline void relax(int no) {&#13;
		int le = gleft(no), ri = gright(no);&#13;
		tree[le].add += tree[no].add;&#13;
		tree[le].sum += tree[no].add * (tree[le].en - tree[le].be + 1);&#13;
		tree[le].maxv += tree[no].add;&#13;
		tree[ri].add += tree[no].add;&#13;
		tree[ri].sum += tree[no].add * (tree[ri].en - tree[ri].be + 1);&#13;
		tree[ri].maxv += tree[no].add;&#13;
		tree[no].add = 0;&#13;
	}&#13;
	void down(int l, int r, int no, t ranadd){&#13;
		if(l &lt;= tree[no].be &amp;&amp; r &gt;= tree[no].en){&#13;
			tree[no].add += ranadd;&#13;
			tree[no].sum += ranadd * (tree[no].en - tree[no].be + 1);&#13;
			tree[no].maxv += ranadd;&#13;
			return;&#13;
		}&#13;
		if(tree[no].add &amp;&amp; tree[no].be != tree[no].en) relax(no);&#13;
		int mid = (tree[no].be + tree[no].en) &gt;&gt; 1;&#13;
		if(r &gt;= tree[no].be &amp;&amp; l &lt;= mid) down(l, r, gleft(no), ranadd);&#13;
		if(r &gt;= mid + 1 &amp;&amp; l &lt;= tree[no].en) down(l, r, gright(no), ranadd);&#13;
		tree[no].sum = tree[gleft(no)].sum + tree[gright(no)].sum;&#13;
		tree[no].maxv = max1(tree[gleft(no)].maxv, tree[gright(no)].maxv);&#13;
	}&#13;
	t getsum(int l, int r, int no){&#13;
		if(l &gt; r) return 0;&#13;
		if(l &lt;= tree[no].be &amp;&amp; r &gt;= tree[no].en)&#13;
			return tree[no].sum;&#13;
		if(tree[no].add &amp;&amp; tree[no].be != tree[no].en) relax(no);&#13;
		t ans = 0;&#13;
		int mid = (tree[no].be + tree[no].en) &gt;&gt; 1;&#13;
		if(r &gt;= tree[no].be &amp;&amp; l &lt;= mid) ans += getsum(l, r, gleft(no));&#13;
		if(r &gt;= mid + 1 &amp;&amp; l &lt;= tree[no].en) ans += getsum(l, r, gright(no));&#13;
		return ans;&#13;
	}&#13;
	int getrank(int rank, int no){&#13;
		if(rank &gt; tree[no].sum) return -1;&#13;
		if(tree[no].be == tree[no].en) return tree[no].be;&#13;
		if(tree[no].add &amp;&amp; tree[no].be != tree[no].en) relax(no);&#13;
		int mid = (tree[no].be + tree[no].en) &gt;&gt; 1;&#13;
		if(rank &lt;= tree[gleft(no)].sum) return getrank(rank, gleft(no));&#13;
		return getrank(rank - tree[gleft(no)].sum, gright(no));&#13;
	}&#13;
	inline int section_getrank(int l, int r, int rank){&#13;
		return getrank(rank + getsum(0, l - 1, 1), 1);&#13;
	}&#13;
};&#13;
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temsua">//待排序的字符串放在r 数组中，从r[0]到r[n-1]，长度为n，且单个字符最大值小于m。sa为结果 &#13;
#define maxn ${maxn}&#13;
int wa[maxn * 2],wb[maxn * 2],wv[maxn * 2],ws1[maxn * 2];&#13;
int cmp(int *r,int a,int b,int l)&#13;
{return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}&#13;
void da(int *r,int *sa,int n,int m) {&#13;
     int i,j,p,*x=wa,*y=wb,*t;&#13;
     for(i=0;i&lt;m;i++) ws1[i]=0;&#13;
     for(i=0;i&lt;n;i++) ws1[x[i]=r[i]]++;&#13;
     for(i=1;i&lt;m;i++) ws1[i]+=ws1[i-1];&#13;
     for(i=n-1;i&gt;=0;i--) sa[--ws1[x[i]]]=i;&#13;
     for(j=1,p=1;p&lt;=n;j*=2,m=p) {&#13;
       for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;&#13;
       for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;&#13;
       for(i=0;i&lt;n;i++) wv[i]=x[y[i]];&#13;
       for(i=0;i&lt;m;i++) ws1[i]=0;&#13;
       for(i=0;i&lt;n;i++) ws1[wv[i]]++;&#13;
       for(i=1;i&lt;m;i++) ws1[i]+=ws1[i-1];&#13;
       for(i=n-1;i&gt;=0;i--) sa[--ws1[wv[i]]]=y[i];&#13;
       for(t=x,x=y,y=t,p=2,x[sa[0]]=1,i=1;i&lt;n;i++)&#13;
       x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;&#13;
     }&#13;
     return;&#13;
}&#13;
void calheight(int *r, int *sa, int*rank, int*height,int n) {&#13;
     int i,j,k=0;&#13;
     for(i=0; i&lt;n;i++) rank[sa[i]]=i;&#13;
     for(i=0;i&lt;n;i++){&#13;
    	 if(rank[i] == 0) continue;&#13;
	     for(k?k--:0,j=sa[rank[i]-1]; i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; r[i+k]==r[j+k];k++);&#13;
	     height[rank[i] - 1]=k;&#13;
     }&#13;
     return;&#13;
}&#13;
int d[20];&#13;
int logg[maxn];&#13;
int st[maxn][22];&#13;
// h为height数组，n为长度&#13;
void InitRMQ(const int &amp;n, int *h) {&#13;
	int i, j;&#13;
	for( d[0]=1, i=1; i &lt; 21; ++i ) d[i] = 2*d[i-1];&#13;
	for( i=0; i &lt; n; ++i ) st[i][0] = h[i];&#13;
	int k = int( log(double(n))/log(2) ) + 1;&#13;
	logg[0] = 0; logg[1] = 0;&#13;
	for(int i = 2; i &lt;= n; i++) logg[i] = logg[i / 2] + 1;&#13;
	for( j=1; j &lt; k; ++j )&#13;
		for( i=0; i &lt; n; ++i ) {&#13;
			if( i+d[j-1]-1 &lt; n ){&#13;
				st[i][j] = min(st[i][j-1],&#13;
						st[i+d[j-1]][j-1]);&#13;
			}&#13;
			else break; // st[i][j] = st[i][j-1];&#13;
		}&#13;
}&#13;
//x, y为rank的序号(在sa中为x和y位置的lcp应为quelcp(x, y))&#13;
inline int quelcp(int x, int y) {&#13;
	int k = logg[y - x + 1];&#13;
	return min(st[x][k], st[y-d[k]+1][k]);&#13;
}&#13;
//此为真正的quelcp(y--）&#13;
inline int quelcp1(int x, int y) {&#13;
	if(y &lt; x) swap(x, y);&#13;
	y--;&#13;
	int k = logg[y - x + 1];&#13;
	return min(st[x][k], st[y-d[k]+1][k]);&#13;
}&#13;
//querange为询问rank序号为no的位置与之lcp &gt;= height的左右边界&#13;
inline pii querange(int no, int height, int l) {&#13;
	int be1 = 0, en1 = no - 1;&#13;
	while(be1 &lt; en1) {&#13;
		int height1 = (be1 + en1) / 2;&#13;
		if(quelcp(height1, no - 1) &lt; height) be1 = height1 + 1;&#13;
		else en1 = height1;&#13;
	}&#13;
	if(quelcp(be1, no - 1) &lt; height) be1++;&#13;
	int from = min1(be1, no);&#13;
	be1 = no; en1 = l - 1;&#13;
	while(be1 &lt; en1) {&#13;
		int height1 = (be1 + en1 + 1) / 2;&#13;
		if(quelcp(no, height1) &lt; height) en1 = height1 - 1;&#13;
		else be1 = height1;&#13;
	}&#13;
	if(quelcp(no, be1) &lt; height) be1--;&#13;
	int to = max1(be1 + 1, no);&#13;
	return mpr(from, to);&#13;
}&#13;
${cursor}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temsua">//待排序的字符串放在r 数组中，从r[0]到r[n-1]，长度为n，且单个字符最大值小于m。sa为结果 &#13;
#define maxn ${maxn}&#13;
int wa[maxn * 2],wb[maxn * 2],wv[maxn * 2],ws1[maxn * 2];&#13;
int cmp(int *r,int a,int b,int l)&#13;
{return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}&#13;
void da(int *r,int *sa,int n,int m) {&#13;
     int i,j,p,*x=wa,*y=wb,*t;&#13;
     for(i=0;i&lt;m;i++) ws1[i]=0;&#13;
     for(i=0;i&lt;n;i++) ws1[x[i]=r[i]]++;&#13;
     for(i=1;i&lt;m;i++) ws1[i]+=ws1[i-1];&#13;
     for(i=n-1;i&gt;=0;i--) sa[--ws1[x[i]]]=i;&#13;
     for(j=1,p=1;p&lt;=n;j*=2,m=p) {&#13;
       for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;&#13;
       for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;&#13;
       for(i=0;i&lt;n;i++) wv[i]=x[y[i]];&#13;
       for(i=0;i&lt;m;i++) ws1[i]=0;&#13;
       for(i=0;i&lt;n;i++) ws1[wv[i]]++;&#13;
       for(i=1;i&lt;m;i++) ws1[i]+=ws1[i-1];&#13;
       for(i=n-1;i&gt;=0;i--) sa[--ws1[wv[i]]]=y[i];&#13;
       for(t=x,x=y,y=t,p=2,x[sa[0]]=1,i=1;i&lt;n;i++)&#13;
       x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;&#13;
     }&#13;
     return;&#13;
}&#13;
void calheight(int *r, int *sa, int*rank, int*height,int n) {&#13;
     int i,j,k=0;&#13;
     for(i=0; i&lt;n;i++) rank[sa[i]]=i;&#13;
     for(i=0;i&lt;n;i++){&#13;
    	 if(rank[i] == 0) continue;&#13;
	     for(k?k--:0,j=sa[rank[i]-1]; i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; r[i+k]==r[j+k];k++);&#13;
	     height[rank[i] - 1]=k;&#13;
     }&#13;
     return;&#13;
}&#13;
int d[20];&#13;
int logg[maxn];&#13;
int st[maxn][22];&#13;
// h为height数组，n为长度&#13;
void InitRMQ(const int &amp;n, int *h) {&#13;
	int i, j;&#13;
	for( d[0]=1, i=1; i &lt; 21; ++i ) d[i] = 2*d[i-1];&#13;
	for( i=0; i &lt; n; ++i ) st[i][0] = h[i];&#13;
	int k = int( log(double(n))/log(2) ) + 1;&#13;
	logg[0] = 0; logg[1] = 0;&#13;
	for(int i = 2; i &lt;= n; i++) logg[i] = logg[i / 2] + 1;&#13;
	for( j=1; j &lt; k; ++j )&#13;
		for( i=0; i &lt; n; ++i ) {&#13;
			if( i+d[j-1]-1 &lt; n ){&#13;
				st[i][j] = min(st[i][j-1],&#13;
						st[i+d[j-1]][j-1]);&#13;
			}&#13;
			else break; // st[i][j] = st[i][j-1];&#13;
		}&#13;
}&#13;
//x, y为rank的序号(在sa中为x和y位置的lcp应为quelcp(x, y))&#13;
inline int quelcp(int x, int y) {&#13;
	int k = logg[y - x + 1];&#13;
	return min(st[x][k], st[y-d[k]+1][k]);&#13;
}&#13;
//此为真正的quelcp(y--）&#13;
inline int quelcp1(int x, int y) {&#13;
	if(y &lt; x) swap(x, y);&#13;
	y--;&#13;
	int k = logg[y - x + 1];&#13;
	return min(st[x][k], st[y-d[k]+1][k]);&#13;
}&#13;
//querange为询问rank序号为no的位置与之lcp &gt;= height的左右边界&#13;
inline pii querange(int no, int height, int l) {&#13;
	int be1 = 0, en1 = no - 1;&#13;
	while(be1 &lt; en1) {&#13;
		int height1 = (be1 + en1) / 2;&#13;
		if(quelcp(height1, no - 1) &lt; height) be1 = height1 + 1;&#13;
		else en1 = height1;&#13;
	}&#13;
	if(quelcp(be1, no - 1) &lt; height) be1++;&#13;
	int from = min1(be1, no);&#13;
	be1 = no; en1 = l - 1;&#13;
	while(be1 &lt; en1) {&#13;
		int height1 = (be1 + en1 + 1) / 2;&#13;
		if(quelcp(no, height1) &lt; height) en1 = height1 - 1;&#13;
		else be1 = height1;&#13;
	}&#13;
	if(quelcp(no, be1) &lt; height) be1--;&#13;
	int to = max1(be1 + 1, no);&#13;
	return mpr(from, to);&#13;
}&#13;
${cursor}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temtarjan">/*==================================================*\&#13;
| Tarjan强连通分量&#13;
| INIT: vec[]为邻接表; stop, cnt, scnt置0; pre[]置-1;&#13;
| CALL: for(i=0; i&lt;n; ++i) if(-1==pre[i]) tarjan(i, n);&#13;
\*==================================================*/&#13;
const int V = ${rv};&#13;
const int maxm = ${rm};&#13;
struct edge {&#13;
	int to, nxt;&#13;
} e[maxm];&#13;
int head[maxm], le;&#13;
inline void addedge(int a, int b) {&#13;
	e[le].to = b;&#13;
	e[le].nxt = head[a];&#13;
	head[a] = le++;&#13;
}&#13;
int id[V], pre[V], low[V], s[V], stop, cnt, scnt;&#13;
void tarjan(int v, int n) { // vertex: 0 ~ n-1&#13;
	int t, minc = low[v] = pre[v] = cnt++;&#13;
	s[stop++] = v;&#13;
	for (int i = head[v]; i != -1; i = e[i].nxt) {&#13;
		if (-1 == pre[e[i].to]) tarjan(e[i].to, n);&#13;
		if (low[e[i].to] &lt; minc) minc = low[e[i].to];&#13;
	}&#13;
	if (minc &lt; low[v]) {&#13;
		low[v] = minc;&#13;
		return;&#13;
	}&#13;
	do {&#13;
		id[t = s[--stop]] = scnt;&#13;
		low[t] = n;&#13;
	} while (t != v);&#13;
	++scnt; // 强连通分量的个数&#13;
}&#13;
&#13;
${cursor}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temtarjan">/*==================================================*\&#13;
| Tarjan强连通分量&#13;
| INIT: vec[]为邻接表; stop, cnt, scnt置0; pre[]置-1;&#13;
| CALL: for(i=0; i&lt;n; ++i) if(-1==pre[i]) tarjan(i, n);&#13;
\*==================================================*/&#13;
const int V = ${rv};&#13;
const int maxm = ${rm};&#13;
struct edge {&#13;
	int to, nxt;&#13;
} e[maxm];&#13;
int head[maxm], le;&#13;
inline void addedge(int a, int b) {&#13;
	e[le].to = b;&#13;
	e[le].nxt = head[a];&#13;
	head[a] = le++;&#13;
}&#13;
int id[V], pre[V], low[V], s[V], stop, cnt, scnt;&#13;
void tarjan(int v, int n) { // vertex: 0 ~ n-1&#13;
	int t, minc = low[v] = pre[v] = cnt++;&#13;
	s[stop++] = v;&#13;
	for (int i = head[v]; i != -1; i = e[i].nxt) {&#13;
		if (-1 == pre[e[i].to]) tarjan(e[i].to, n);&#13;
		if (low[e[i].to] &lt; minc) minc = low[e[i].to];&#13;
	}&#13;
	if (minc &lt; low[v]) {&#13;
		low[v] = minc;&#13;
		return;&#13;
	}&#13;
	do {&#13;
		id[t = s[--stop]] = scnt;&#13;
		low[t] = n;&#13;
	} while (t != v);&#13;
	++scnt; // 强连通分量的个数&#13;
}&#13;
&#13;
${cursor}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temtreearray">#ifndef N&#13;
#define N 1 &lt;&lt; 17&#13;
#endif&#13;
template &lt;class t&gt; struct tree_array{&#13;
	t num[N], n, bigwei;&#13;
	void init(int nn = N){&#13;
		n = nn;&#13;
		while(lowb(nn) != nn) nn -= lowb(nn);&#13;
		bigwei = nn;&#13;
		n = bigwei * 2;&#13;
	}&#13;
	void upd(int no, t add){&#13;
		while(no &lt;= n){&#13;
			num[no] += add;&#13;
			no += lowb(no);&#13;
		}&#13;
	}&#13;
	t que(int no){&#13;
		t ans = 0;&#13;
		while(no){&#13;
			ans += num[no];&#13;
			no -= lowb(no);&#13;
		}&#13;
		return ans;&#13;
	}&#13;
	 int getrank(t x){&#13;
		 int ans = 0, ranwei = bigwei; t rank = 0;&#13;
		 while(ranwei){&#13;
			 if(rank + num[ranwei + ans] &lt; x){&#13;
				 ans += ranwei;&#13;
				 rank += num[ans];&#13;
			 }&#13;
			 ranwei &gt;&gt;= 1;&#13;
		 }&#13;
		 return ans + 1;&#13;
	 }&#13;
};</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temtreearray">#ifndef N&#13;
#define N 1 &lt;&lt; 17&#13;
#endif&#13;
template &lt;class t&gt; struct tree_array{&#13;
	t num[N], n, bigwei;&#13;
	void init(int nn = N){&#13;
		n = nn;&#13;
		while(lowb(nn) != nn) nn -= lowb(nn);&#13;
		bigwei = nn;&#13;
		n = bigwei * 2;&#13;
	}&#13;
	void upd(int no, t add){&#13;
		while(no &lt;= n){&#13;
			num[no] += add;&#13;
			no += lowb(no);&#13;
		}&#13;
	}&#13;
	t que(int no){&#13;
		t ans = 0;&#13;
		while(no){&#13;
			ans += num[no];&#13;
			no -= lowb(no);&#13;
		}&#13;
		return ans;&#13;
	}&#13;
	 int getrank(t x){&#13;
		 int ans = 0, ranwei = bigwei; t rank = 0;&#13;
		 while(ranwei){&#13;
			 if(rank + num[ranwei + ans] &lt; x){&#13;
				 ans += ranwei;&#13;
				 rank += num[ans];&#13;
			 }&#13;
			 ranwei &gt;&gt;= 1;&#13;
		 }&#13;
		 return ans + 1;&#13;
	 }&#13;
};</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="for loop with temporary variable" enabled="true" id="org.eclipse.cdt.ui.text.templates.cpp.for" name="tfo">for (int ${var} = ${min}; ${var} &lt; ${max}; ++${var}) {
	${line_selection}${cursor}
}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="if else statement" enabled="true" id="org.eclipse.cdt.ui.text.templates.c.ifelse" name="tie">if (${condition}) {
	${cursor}
} else {
	
}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="if statement" enabled="true" id="org.eclipse.cdt.ui.text.templates.c.if" name="tif">if (${condition}) {
	${line_selection}${cursor}
}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="for loop from big to small" enabled="true" name="trfo">for (int ${var} = ${min}; ${var} &gt;= ${max}; --${var}) {&#13;
	${line_selection}${cursor}&#13;
}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="try catch block" enabled="true" id="org.eclipse.cdt.ui.text.templates.cpp.try" name="try">try {
	${line_selection}${cursor}
} catch (${Exception} e) {
}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="tst">struct ${name}{&#13;
	${line_selection}${cursor}&#13;
};</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="twh">while (${condition}) {&#13;
	${line_selection}${cursor}&#13;
}</template></templates>