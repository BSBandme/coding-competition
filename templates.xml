<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="" enabled="true" name="temkm">/*=================================================*\&#13;
| 二分图最佳匹配（kuhn munkras算法O(m*m*n）&#13;
| 邻接距阵形式,复杂度O(m*m*n) 返回最佳匹配值,传入二分图大小m,n&#13;
| 邻接距阵mat,表示权, match1,match2返回一个最佳匹配,未匹配顶点&#13;
| match值为-1, 一定注意m&lt;=n,否则循环无法终止,最小权匹配可将权值&#13;
| 取相反数&#13;
| 初始化：for( i=0 ; i &lt; MAXN ; ++i )&#13;
|                for( j=0 ; j &lt; MAXN ; ++j ) mat[i][j] = -inf;&#13;
| 对于存在的边：mat[i][j] = val ; // 注意，不能有负值&#13;
| 此为先最大后最佳匹配，若求先最佳匹配，将init中改为mat[i][j] = 0;&#13;
\*==================================================*/&#13;
#define MAXN 310&#13;
#define inf 1000000000&#13;
#define _clr(x) memset(x,-1,sizeof(int)*MAXN*2)&#13;
int km(int m, int n, int mat[][MAXN], int* match1, int* match2) {&#13;
	int s[MAXN*2], t[MAXN*2], l1[MAXN*2], l2[MAXN*2], p, q, ret = 0, i, j, k;&#13;
	for (i = 0; i &lt; m; i++) {&#13;
		for (l1[i] = -inf, j = 0; j &lt; n; j++)&#13;
			l1[i] = mat[i][j] &gt; l1[i] ? mat[i][j] : l1[i];&#13;
		if (l1[i] == -inf)&#13;
			return -1; // 无法匹配！&#13;
	}&#13;
	for (i = 0; i &lt; n; l2[i++] = 0);&#13;
	for (_clr(match1), _clr(match2), i = 0; i &lt; m; i++) {&#13;
		for (_clr(t), s[p = q = 0] = i; p &lt;= q &amp;&amp; match1[i] &lt; 0; p++)&#13;
			for (k = s[p], j = 0; j &lt; n &amp;&amp; match1[i] &lt; 0; j++)&#13;
				if (l1[k] + l2[j] == mat[k][j] &amp;&amp; t[j] &lt; 0) {&#13;
					s[++q] = match2[j], t[j] = k;&#13;
					if (s[q] &lt; 0)&#13;
						for (p = j; p &gt;= 0; j = p)&#13;
							match2[j] = k = t[j], p = match1[k], match1[k] = j;&#13;
				}&#13;
		if (match1[i] &lt; 0) {&#13;
			for (i--, p = inf, k = 0; k &lt;= q; k++)&#13;
				for (j = 0; j &lt; n; j++)&#13;
					if (t[j] &lt; 0 &amp;&amp; l1[s[k]] + l2[j] - mat[s[k]][j] &lt; p)&#13;
						p = l1[s[k]] + l2[j] - mat[s[k]][j];&#13;
			for (j = 0; j &lt; n; l2[j] += t[j] &lt; 0 ? 0 : p, j++);&#13;
			for (k = 0; k &lt;= q; l1[s[k++]] -= p);&#13;
		}&#13;
	}&#13;
	for (i = 0; i &lt; m; i++) { // if处理无匹配的情况！！&#13;
		if (match1[i] &lt; 0)&#13;
			return -1;&#13;
		if (mat[i][match1[i]] &lt;= -inf)&#13;
			return -1;&#13;
		ret += mat[i][match1[i]];&#13;
	}&#13;
	return ret;&#13;
}&#13;
</template></templates>